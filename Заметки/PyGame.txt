#---Импортируем библиотеку pygame---
import pygame
#---Инциализация---
pygame.init()
#---Создание окна---
pygame.display.set_mode((800, 600))
#---Главный игровой цикл---
run = True
while run:
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            run = False
#---Закрытие всех модулей Pygame---
pygame.quit()


#Инциализация
pygame.init()

#Закрытие всех модулей Pygame
pygame.quit()

#Создание окна
pygame.display.set_mode(size, flags=0, depth=0, display=0, vsync=0)

• size: Кортеж (ширина, высота) — размеры окна в пикселях.
• flags: Необязательный параметр, который задает дополнительные параметры (например, pygame.FULLSCREEN для полноэкранного режима).
• depth: Необязательный параметр, который задает глубину цвета (обычно не используется).
• display: Необязательный параметр, указывающий на конкретный дисплей (в основном для многомониторных систем).
• vsync: Необязательный параметр для включения вертикальной синхронизации.

#Cписок всех событий, произошедших с последнего кадра
pygame.event.get()

Использовать вот так:
for e in pygame.event.get():
        if e.type == pygame.QUIT:
            run = False


Основные атрибуты объекта pygame.event.Event включают:

type: тип события (например, pygame.QUIT, pygame.KEYDOWN и т.д.).
dict: словарь с дополнительными данными, который может содержать любую информацию, специфичную для данного события.


Для события нажатия клавиши (KEYDOWN) дополнительный словарь может содержать:

key: идентификатор нажатой клавиши.
mod: модификаторы клавиш (например, Shift, Ctrl).


Для события мыши (MOUSEBUTTONDOWN) словарь может содержать:

pos: координаты курсора мыши в момент нажатия кнопки.
button: номер кнопки мыши, которая была нажата.


for e in pygame.event.get():
    if e.type == pygame.QUIT:
        run = False
    
    if e.type == pygame.KEYDOWN:
        my_key = e.key
        my_mod = e.mod
        print(f"Нажата клавиша: {pygame.key.name(my_key)}")
        print(f"Модификатор: {my_mod}")
    if e.type == pygame.MOUSEBUTTONDOWN:
        my_pos = e.pos
        my_button = e.button
        print(f"Позиция мыши: {my_pos}")
        print(f"Идентификатор кнопки мыши: {my_button}")

Так как pygame.event.get() это есть список, то будем применять цикл for in, для извлечения элементов списка (типов событий) в переменную e (имя этой переменной мы придумали сами).
У нас в коде в обработке три события. 
Первый тип: pygame.QUIT, мы его немного разобрали в предыдущей статье. Тип события - закрытие окна. Как только этот тип срабатывает, в переменную run помещается значение False и мы грамотно выходим из главного игрового цикла. Вся, программа после pygame.quit() корректно  завершается.
Второй тип: pygame.KEYDOWN. Обрабатывает событие нажатия клавиши, в нашем случае любой клавиши на клавиатуре. У клавиш есть данные объекта, это key  и mod. В программе, помещаем их в наши переменные и выводим информацию на консоль. Переменную my_key используем как параметр в функции pygame.key.name(my_key)
Функция pygame.key.name() в библиотеке pygame, используется для получения строкового представления имени клавиши на основе её кода. Эта функция полезна для отображения информации о нажатых клавишах в игре. 
Также обратите внимание на переменную my_mod, поэкспериментируйте с нажатием  клавиши Caps Lock, Shift и других клавиш. Вся информация по нажатым клавишам будет выводиться на консоль.
Третий тип: pygame.MOUSEBUTTONDOWN. Обрабатывает события нажатий клавиш мыши и их позицию на окне программы, выводит информацию на консоль.
Напишите программу, запустите и поэкспериментируйте нажатиями разных клавиш.


Список основных типов событий
1. QUIT: Событие, возникающее при закрытии окна приложения.
2. KEYDOWN: Событие нажатия клавиши.
3. KEYUP: Событие отпускания клавиши.
4. MOUSEBUTTONDOWN: Событие нажатия кнопки мыши.
5. MOUSEBUTTONUP: Событие отпускания кнопки мыши.
6. MOUSEMOTION: Событие движения мыши.
7. JOYAXISMOTION: Событие изменения положения оси джойстика.
8. JOYBALLMOTION: Событие движения шарикового контроллера (если он есть).
9. JOYHATMOTION: Событие изменения положения хэтч-контроллера (если он есть).
10. JOYBUTTONDOWN: Событие нажатия кнопки на джойстике.
11. JOYBUTTONUP: Событие отпускания кнопки на джойстике.
12. VIDEORESIZE: Событие изменения размера окна.
13. VIDEOEXPOSE: Событие, связанное с обновлением области окна.
14. USEREVENT: Пользовательское событие, которое можно использовать для создания собственных событий.





Rect(left, top, width, height)
Rect((left, top), (width, height))
Для создания объекта такого типа нам необходимо указать координаты левого верхнего угла и длину его стороны:

r = Rect(0, 0, 100, 200)



rect(Surface, color, Rect, width=0) -> Rect

screen = pygame.display.set_mode((1000, 800))
r = pygame.Rect(50, 50, 100, 200)
pygame.draw.rect(screen, (255, 0, 0), r, 0)



pygame.display.flip()

Обратите внимание на внешний вид нашей программы. 
На самом деле графические объекты, которые мы хотим разместить на экране, 
сначала обратите внимание на специальный буфер. 
Чтобы отобразить изменения, стали вызывать функцию flip().


Функции для рисования графических фигур:

pygame.draw.rect( Поверхность , цвет , Прямоугольник , ширина=0 )
Нарисовать контур Rectна поверхности Surfaceцветом color. Если защита линии остается опасной width, тень закрашивается.

pygame.draw.line( Поверхность , цвет , начальная_позиция , конечная_позиция , ширина=1 )
Нарисовать линию на поверхности Surface, цвет color, с началом остановки start_pos, концом в точке end_pos и толщину линии.

pygame.draw.lines( Поверхность , цвет , закрыто , список точек , ширина=1 )
Нарисовать линию, соединяющую точки последовательности pointlist на поверхности Surface, цвет colorс толстой линией width. 
каждая точка представляет координаты парой. Если параметр closedравен True, конечная точка связана с начальным.

pygame.draw.circle( Поверхность , цвет , позиция , радиус , ширина=0 )
Нарисовать окружность поверхности Поверхность, цвет color, центр в центре posи радиус radius. Если основания линии widthравны, окружность закрашивается.

pygame.draw.ellipse( Поверхность , цвет , Прямоугольник , ширина=0 )
Нарисовать эллипс, ограниченный контур Rect, на поверхности Surface, цвет color. Если сопротивление линии widthостается равновесным, эллипс закрашивается.

pygame.draw.polygon( Поверхность , цвет , список точек , ширина=0 )
Нарисовать многоугольник по точкам из последовательности pointlistна поверхности Surface, цвет colorс более толстыми линиями width. 
каждая точка представляет координаты парой. Если опорные линии остаются, то widthмногоугольник закрашивается.




Текст и шрифты
При работе с текстом мы будем использовать шрифты — группы символов, объединенных по стилистическому или иному признаку. 
Шрифты в библиотеке pygame описывают типFont

Чтобы создать объект Fontна основе блеска в системном шрифте, вызовите эту функцию:

SysFont(name, size, bold=False, italic=False)
С помощью параметра nameпередаем в функцию имя шрифта, параметр size- размер шрифта в пунктах. 
Параметры boldи italicвозможности для выбора шрифта.

Список существующих в системе шрифтов можно получить с помощью функции get_fonts():

pygame.font.get_fonts() -> list of strings
Далее с помощью метода render()нашего типа типа Fontполучаем изображение с текстом, 
которое передаем на входной метод blit()для отрисовки на нашем основном экране:

screen = pygame.display.set_mode(size)
screen.fill(THECOLORS['white'])
font = pygame.font.SysFont('couriernew', 40)
text = font.render(str('HELLO'), True, THECOLORS['green'])
screen.blit(text, (50, 50))
Текст размещается на экране по координатам (50, 50)




        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                rect.move_ip(-40, 0)
            elif event.key == pygame.K_RIGHT:
                rect.move_ip(40, 0)
            elif event.key == pygame.K_UP:
                rect.move_ip(0, -40)
            elif event.key == pygame.K_DOWN:
                rect.move_ip(0, 40)

Для движения объектов используются методы move() и move_ip(), 
которыми обладают объекты, созданные с помощью функций из pygame.draw. 
Первый создаёт новую фигуру такого же типа, находящуюся по заданному смещению, 
второй непосредственно изменяет положение имеющейся фигуры.

# здесь могла быть ваша проверка событий
screen.fill((0, 0, 0))
pygame.draw.rect(screen, (255, 0, 0), rect, 0)
pygame.display.flip()





Использование спрайтов
Спрайт - двумерное изображение, используемое в играх.

pygame.image.load( путь )
функция загрузки спрайта из картинок. Path- путь к изображению, возвращает объект типа Surface, который можно использовать для рисования.

Для отрисовки спрайта на экран надо вызвать метод blit()на поверхности, на котором производится отрисовка, и передать объект спрайта вместе с координатами, на которых необходимо отрисовать:

screen = pygame.display.set_mode((640, 480))
sprite = pygame.image.load("sprite.png")

screen.blit(sprite, (20, 20))
pygame.quit()




Анимации
В pygame анимации достигают с помощью набора спрайтов, которые постепенно отрисовываются:


animation_set = [pygame.image.load(f"r{i}.png") for i in range(1, 6)]

window = pygame.display.set_mode((640, 480))

clock = pygame.time.Clock()
i = 0
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    window.fill((0,0,0))
    window.blit(animation_set[i // 12], (100, 20))
    i += 1
    if i == 60:
        i = 0

    pygame.display.flip()
    clock.tick(60)
Создаём список спрайтов, каждый из которых будет вращающимся кадром анимации:

animation_set = [pygame.image.load(f"r{i}.png") for i in range(1, 6)]
Создаём часы, для ограничения количества кадров в секунду:

clock = pygame.time.Clock()
Вспомогательная переменная, которая поможет выбрать нужную анимацию в зависимости от номера кадра:

i = 0
Выбор анимации в зависимости от номера кадра и его отрисовки:

window.blit(animation_set[i // 12], (100, 20))
Изменение переменной, помогающей выбрать нужный кадр:

i += 1
if i == 60:
   i = 0
Ограничение количества кадров в секунду, благодаря чему становится проще просчитывать анимацию и синхронизировать события:

clock.tick(60)









В Pygame для работы с аудио предназначены модули pygame.mixer и pygame.mixer.music. 
Модули похожи, однако pygame.mixer в первую очередь адаптирован для добавления и настройки звуковых эффектов в игре. 
В то время как pygame.mixer.music – для добавления фоновой музыки.


Функция pygame.mixer.music.load() загружает потоковое аудио, 
т. е. не грузит файл целиком, а делает это отдельными порциями. 
В результате можно проигрывать только один файл за раз. Однако можно ставить файлы в очередь функцией queue(). 
Поддерживает, в том числе, формат mp3 (но не в Ubuntu).

С другой стороны, в pygame.mixer ключевым является класс Sound. 
Он позволяет загружать, проигрывать и выполнять ряд других действий с файлами форматов wav или ogg. 
При создании экземпляра Sound в конструктор передается имя файла.

В примере ниже подгружается фоновая музыка: pygame.mixer.music.load(). 
Функция не возвращает никакого "музыкального" объекта, поэтому результат ее вызова не присваивается переменной.

С помощью функции music.play() файл начинает проигрываться. 
Если требуется зациклить композицию, то в play() передается число -1. 
Положительный аргумент указывает на количество повторов + одно дополнительное. 
То есть, если надо проиграть композицию 2 раза, то в функцию передается число 1.

В программе при нажатии на клавишу 1 клавиатуры музыка ставится на паузу: music.pause(). 
Клавиша 2 уменьшает громкость в два раза: music.set_volum(0.5). Нажатие 3 возвращает громкость на прежний уровень. 
Функция unpause() вызывается на случай, если до этого музыка была выключена (клавишей 1).

Если закомментировать вызовы функций pause() и unpause() и раскомментировать stop() и play(), то результат будет схож. 
Разница в том, что при использовании комбинации stop-play файл начнет проигрываться сначала, а при pause-unpause продолжится с места останова.


import pygame as pg
import sys
pg.init()
sc = pg.display.set_mode((400, 300))

pg.mixer.music.load('Beethoven.ogg')
pg.mixer.music.play()

sound1 = pg.mixer.Sound('boom.wav')
sound2 = pg.mixer.Sound('one.ogg')

while 1:
    for i in pg.event.get():
        if i.type == pg.QUIT:
            sys.exit()

        elif i.type == pg.KEYUP:
            if i.key == pg.K_1:
                pg.mixer.music.pause()
                # pygame.mixer.music.stop()
            elif i.key == pg.K_2:
                pg.mixer.music.unpause()
                # pygame.mixer.music.play()
                pg.mixer.music.set_volume(0.5)
            elif i.key == pg.K_3:
                pg.mixer.music.unpause()
                # pygame.mixer.music.play()
                pg.mixer.music.set_volume(1)

        elif i.type == pg.MOUSEBUTTONUP:
            if i.button == 1:
                sound1.play()
            elif i.button == 3:
                sound2.play()

    pg.time.delay(20)







метод get_length() объекта типа Sound. Метод возвращает продолжительность звука, выраженную в секундах (тип float).

pg.mixer.music.load('Beethoven.ogg')
pg.mixer.music.play()


sound1 = pg.mixer.Sound('boom.wav')
sound2 = pg.mixer.Sound('one.ogg')


elif i.type == pg.MOUSEBUTTONUP:
    if i.button == 1:
        sound1.play()
    elif i.button == 3:
        sound2.play()

        
elif i.type == pg.KEYUP:
    if i.key == pg.K_1:
        pg.mixer.music.pause()
        # pygame.mixer.music.stop()
    elif i.key == pg.K_2:
        pg.mixer.music.unpause()
        # pygame.mixer.music.play()
        pg.mixer.music.set_volume(0.5)
    elif i.key == pg.K_3:
        pg.mixer.music.unpause()
        # pygame.mixer.music.play()
        pg.mixer.music.set_volume(1)